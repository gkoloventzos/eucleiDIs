<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Eucleidis by sfagmenos</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <script type="text/javascript" src="animatedcollapse.js">
		/***********************************************
		* Animated Collapsible DIV v2.4- (c) Dynamic Drive DHTML code library (www.dynamicdrive.com)
		* This notice MUST stay intact for legal use
		* Visit Dynamic Drive at http://www.dynamicdrive.com/ for this script and 100s more
		***********************************************/
    </script>
    <script type="text/javascript" src="collapse.js"></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Eucleidis</h1>
        <p>A python geometric library</p>
        <p class="view"><a href="https://github.com/sfagmenos/eucleiDIs">View the Project on GitHub <small>sfagmenos/eucleiDIs</small></a></p>
        <ul>
          <li><a href="https://github.com/sfagmenos/eucleiDIs/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/sfagmenos/eucleiDIs/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/sfagmenos/eucleiDIs">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
<p>EucleiDIs is a python geometric library which imitates CGAL. We are trying to have
the ease of python coding with the capabilities of CGAL.</p>
<p>In the library section you can have a look of the classes,functions, exceptions
of our library. For every class will be have all the functions
properties and outputs</p>
<p>In the examples section you will have the opportunity to see or watch the 
library in action with as many examples we will be able to create</p>
<p>If you want to contact us do not hesitate to see in the contact us area.</p>
<p>The name is coming from the person whose name is strongly attached
to geometry (Eucleides) and the name of our department (DI).</p>
<p>
<a id="show_button" href="javascript:animatedcollapse.show('general')"><i>Show</i></a>
<a style="display: none;" id="hide_button" href="javascript:animatedcollapse.hide('general')"><i>Hide</i></a>
</p>

<div id="general" style="display: none;">
<a id="Library">Library</a> <p><a href="javascript:animatedcollapse.toggle('library')"><i>Show/Hide</i></a></p>
<div id="library" style="display: none;">
<h3>Classes</h3>
<ul>
<li><p><a id="Lpoint2d">Point_2</a>&nbsp;<a href="javascript:animatedcollapse.toggle('lpoint2d')"><i>Show/Hide</i></a></p>
<div id="lpoint2d" style="display: none;">
<p>
<h3 style="color:#111;">Definition</h3>
<p>An object of the class Point_2 is a point in the two-dimensional Euclidean plane.</p>
<a name="constructor"></a><h3 style="color:#111;">Constructor</h3>
<p><code>p = Point_2(x=0,y=0,color=(1,1,1),visible=True)</code>
The contructor of the Point_2 object has as arguments the position
of the point in the 2 dimensional space, the color of which the bullet
will be colored and the visibility of the bullet.
</p>
<a name="operators"></a><h3 style="color:#111;">Operators</h3>
<p><code><strong>bool</strong>  p==q</code>

Returns true if p and q Point_2 objects has the same coordinates.
Returns false otherwise.
</p>
<p><code><strong>bool</strong>  p!=q</code>
Returns true if p and q Point_2 objects has not the same coordinates.
Returns false otherwise.
</p>
<p><code><strong>bool</strong>  p&le;q</code>
Returns true if p coordinates are lesser or equal than q.
Returns false otherwise.
</p>
<p><code><strong>bool</strong>  p&ge;q</code>

Returns true if p coordinates are greater or equal than q.
Returns false otherwise.
</p>
<p><code><strong>bool</strong>  p&lt;q</code>
Returns true if p coordinates are lesser than q.
Returns false otherwise.
</p>
<p><code><strong>bool</strong>  p&gt;q</code>
Returns true if p coordinates are greater than q.
Returns false otherwise.
</p>
<p><code><strong><a href="#Lpoint2d">Point_2</a></strong>  p+v</code>
p is Point_2 and v is Vector_2. Returning the point obtained by translating p by the vector v.
Else raises exception.
</p>
<p><code><strong><a href="#Lpoint2d">Point_2</a></strong>  p-v</code>
p is Point_2 and v is Vector_2. Returning the point obtained by translating p by the vector -v.
Else raises exception.
</p>
<p><code><strong><a href="#Lvector2d">Vector_2</a></strong>  p-q</code>
p and q are Point_2. Returning the difference vector between p and q.
Else raises exception.
</p>
<p><code><strong>float</strong>  p[ int i ]</code>
Returns the i coordinate (0&le;i&le;1).
</p>
<a name="operations"></a><h3 style="color:#111;">Operations</h3>
<p><code><strong>float</strong>  p.x()</code>
Returns the x coordinate.
</p>
<p><code><strong>float</strong>  p.y()</code>
Returns the y coordinate.
</p>
<p><code><strong>float</strong>  p.cartesian( int i )</code>
Returns the i coordinate (0&le;i&le;1).
</p>
<p><code><strong>int</strong>  p.dimension()</code>
Returns 2.
</p>
<p><code><strong>sphere</strong>  p.pos()</code>
Returns the visual python object sphere that Point_2 has as representation.
</p>
<p><code><strong>void</strong>  p.visual(visible=None)</code>
If the argument ommitted then it reverses the visibility.
Otherwise makes the visibility as the argument defines.
</p>
<p><code><strong>void</strong>  p.label("label")</code>
Creates a label with the argument string for the Point_2 p.
</p>
<p><code><strong>void</strong>  p.color(x=0,y=0,z=0)</code>
If color is called as p.color() prints the color of the Point_2<br />
If it is called with with tuple (color.green) or (256,0,0) then it changes
the color of the Point_2.<br />
If you want to color a Point_2 black use the visualfunction(make it invisible).
</p>
</p>
<a href="#Lpoint2d">Point_2</a>&nbsp;&nbsp;&nbsp;<a href="#Library">Library</a>&nbsp;&nbsp;&nbsp;<a href="#">Top</a><br /></div></li>
<li><p><a id="Lsegment2d">Segment_2</a>&nbsp;<a href="javascript:animatedcollapse.toggle('lsegment2d')"><i>Show/Hide</i></a></p>
<div id="lsegment2d" style="display: none;">
<p>
<h3 style="color:#111;">Definition</h3>
<p>An object of the class Segment_2 is a directed straight line segment in the two-dimensional Euclidean plane 2, i.e. a straight line segment [p,q] connecting two points p,q in R 2. The segment is topologically closed, i.e. the end points belong to it. Point p is called the source and q is called the target of s. The length of s is the Euclidean distance between p and q. Note that there is only a function to compute the square of the length, because otherwise we had to perform a square root operation which is not defined for all number types, which is expensive, and may not be exact.</p>
<a name="constructor"></a><h3 style="color:#111;">Constructor</h3>
<p><code>s = Segment_2(&lt;<a href="#Lpoint2d">Point_2</a>&gt; source,&lt;<a href="#Lpoint2d">Point_2</a>&gt; target, color=(1,1,1), visible=True)</code>
The constructor of Segment_2 class has as arguments 2 Point_2 objects for the source and target points.
Also has the color of the line will be colored and the visibility of the line.
</p>
<a name="operations"></a><h3 style="color:#111;">Operations</h3>
<p><code><strong><a href="#Lpoint2d">Point_2</a></strong>  s.source()</code>
Returns the source of s. 
</p>
<p><code><strong><a href="#Lpoint2d">Point_2</a></strong>  s.target()</code>
Returns the target of s. 
</p>
<p><code><strong><a href="#Lpoint2d">Point_2</a></strong>  s.min()</code>
Returns the point of s with lexicographically smallest coordinate. 
</p>
<p><code><strong><a href="#Lpoint2d">Point_2</a></strong>  s.max()</code>
Returns the point of s with lexicographically largest coordinate. 
</p>
<p><code><strong><a href="#Lpoint2d">Point_2</a></strong>  s.middle()</code>
Returns the point which is in the middle of s. 
</p>
<p><code><strong><a href="#Lpoint2d">Point_2</a></strong>  s.vertex( int i )</code>
Returns source or target of s: vertex(0) returns the source of s, vertex(1) returns the target of s.
</p>
<p><code><strong><a href="#Lpoint2d">Point_2</a></strong>  s.point( int i )</code>
Returns the vertex(i).
</p>
<p><code><strong>float</strong>  s.squared_length()</code>
Returns the squared length of s. 
</p>
<p><code><strong><a href="#Ldirection2d">Direction_2</a></strong>  s.direction()</code>
Returns the direction from source to target of s.
</p>
<p><code><strong><a href="#Lvector2d">Vector_2</a></strong>  s.to_vector()</code>
Returns the vector s.target() - s.source().
</p>
<p><code><strong><a href="#Lsegment2d">Segment_2</a></strong>  s.opposite()</code>
Returns a segment with source and target point interchanged. 
</p>
<p><code><strong><a href="#Lline2d">Line_2</a></strong>  s.supporting_line()</code>
Returns the line l passing through s. Line l has the same orientation as segment s. 
</p>
<p><code><strong>void</strong>  s.visual(visible=None)</code>
If the argument ommitted then it reverses the visibility.
Otherwise makes the visibility as the argument defines.
</p>
<p><code><strong>void</strong>  s.label("label")</code>
Creates a label with the argument string for the Segment_2 p.
</p>
<p><code><strong>void</strong>  s.color(x=0,y=0,z=0)</code>
If color is called as p.color() prints the color of the Segment_2<br />
If it is called with with tuple (color.green) or (256,0,0) then it changes
the color of the Segment_2.<br />
If you want to color a Segment_2 black use the visualfunction(make it invisible).
</p>
<a name="predicates"></a><h3 style="color:#111;">Predicates</h3>
<p><code><strong>bool</strong>  s.is_degenarate()</code>
Segment s is degenerate, if source and target are equal. 
</p>
<p><code><strong>bool</strong>  s.is_horizontal()</code>
</p>
<p><code><strong>bool</strong>  s.is_vertical()</code>
</p>
<p><code><strong>bool</strong>  s.has_on(<a href="#Lpoint2d">Point_2</a> p)</code>
A point is on s, iff it is equal to the source or target of s, or if it is in the interior of s.
</p>
</p>
<a href="#Lsegment2d">Segment_2</a>&nbsp;&nbsp;&nbsp;<a href="#Library">Library</a>&nbsp;&nbsp;&nbsp;<a href="#">Top</a><br /></div></li>
<li><p><a id="Lvector2d">Vector_2</a>&nbsp;<a href="javascript:animatedcollapse.toggle('lvector2d')"><i>Show/Hide</i></a></p>
<div id="lvector2d" style="display: none;">
<p>
<h3 style="color:#111;">Definition</h3>
<p>An object of the class Vector_2 is a vector in the two-dimensional vector space. Geometrically spoken, a vector is the difference of two points p2, p1 and denotes the direction and the distance from p1 to p2.</p>
<a name="constructor"></a><h3 style="color:#111;">Constructor</h3>
<p><code>
v = Vector_2(&lt;<strong><a href="#Lpoint2d">Point_2</a></strong>&gt; a, &lt;<strong><a href="#Lpoint2d">Point_2</a></strong>&gt; b, visible=True)
</code>
Introduces the vector b-a. 
</p>
<p><code>
v = Vector_2(int a, int b, visible=True)
</code>Introduces a vector v initialized to (x,y). 
</p>
<p><code>
v = Vector_2(float a, float b, visible=True)
</code>Introduces a vector v initialized to (x,y). 
</p>
<p><code>
v = Vector_2(&lt;<strong><a href="#Lsegment2d">Segment_2</a></strong>&gt; s, visible=True)
</code>
Introduces the vector s.target()-s.source(). 
</p>
<p><code>
v = Vector_2(&lt;<strong><a href="#Lray2d">Ray_2</a></strong>&gt; r, visible=True)
</code>Introduces the vector having the same direction as r. 
</p>
<p><code>
v = Vector_2(&lt;<strong><a href="#Lline2d">Line_2</a></strong>&gt; l, visible=True)
</code>Introduces the vector having the same direction as l. 
</p>
<a name="operators"></a><h3 style="color:#111;">Operators</h3>
<p><code><strong>bool</strong>  v==w</code>
Returns true if v and w Vector_2 objects are the same object.
Returns false otherwise.
</p>
<p><code><strong><a href="#Lvector2d">Vector_2</a></strong>  v+w</code>
Addition of 2 vectors. 
</p>
<p><code><strong><a href="#Lvector2d">Vector_2</a></strong>  v-w</code>
Subtraction of 2 vectors.
</p>
<p><code><strong>int</strong>  v*w</code>
V and w are both Vector_2 objects. It returns the inner product of the vectors.
</p>
<p><code><strong><a href="#Lvector2d">Vector_2</a></strong>  v*&lt;int&gt; w</code>
Simple scalar multiplication of the vector is returned.
</p>
<p><code><strong><a href="#Lvector2d">Vector_2</a></strong>  v/&lt;int&gt; w</code>
Simple scalar division of the vector is returned.
</p>
<p><code><strong><a href="#Lvector2d">Vector_2</a></strong>  -v</code>
Returns the opposite vector.
</p>
<p><code><strong>float</strong>  v[ int i ]</code>
Returns the i coordinate (0&le;i&le;1).
</p>
<a name="operations"></a><h3 style="color:#111;">Operations</h3>
<p><code><strong>float</strong>  v.x()</code>
Returns the x coordinate.
</p>
<p><code><strong>float</strong>  v.y()</code>
Returns the y coordinate.
</p>
<p><code><strong>float</strong>  v.cartesian( int i )</code>
Returns the i coordinate (0&le;i&le;1).
</p>
<p><code><strong>int</strong>  v.dimension()</code>
Returns 2.
</p>
<p><code><strong><a href="#Ldirection2d">Direction_2</a></strong>  v.direction()</code>
Returns the direction which passes through v.
</p>
<p><code><strong>float</strong> v.squared_length()</code>
Returns the squared length of v. 
</p>
<p><code><strong>float</strong> v.angle()</code>
Returns the angle of v with the x axis in degrees. 
</p>
</p>
<a href="#Lvector2d">Vector_2</a>&nbsp;&nbsp;&nbsp;<a href="#Library">Library</a>&nbsp;&nbsp;&nbsp;<a href="#">Top</a><br /></div></li>
<li><p><a id="Ldirection2d">Direction_2</a>&nbsp;<a href="javascript:animatedcollapse.toggle('ldirection2d')"><i>Show/Hide</i></a></p>
<div id="ldirection2d" style="display: none;">
<p>
<h3 style="color:#111;">Definition</h3>
<p>
An object of the class Direction_2 is a vector in the two-dimensional vector space where we forget about its length. They can be viewed as unit vectors, although there is no normalization internally, since this is error prone. Directions are used whenever the length of a vector does not matter. They also characterize a set of parallel oriented lines that have the same orientations. For example, you can ask for the direction orthogonal to an oriented plane, or the direction of an oriented line. Further, they can be used to indicate angles. The slope of a direction is dy()/dx(). 
</p>
<a name="constructor"></a><h3 style="color:#111;">Constructor</h3>
<p><code>
d = Direction_2(&lt;<strong><a href="#Lsegment2d">Segment_2</a></strong>&gt; s)
</code>
Introduces the direction d of segment s. 
</p>
<p><code>
d = Direction_2(&lt;<strong><a href="#Lvector2d">Vector_2</a></strong>&gt; v)
</code>
Introduces the direction d of vector v. 
</p>
<p><code>
d = Direction_2(&lt;<strong><a href="#Lline2d">Line_2</a></strong>&gt; l)
</code>
Introduces the direction d of line l.
</p>
<p><code>
d = Direction_2(&lt;<strong><a href="#Lray2d">Ray_2</a></strong>&gt; r)
</code>
Introduces the direction d of ray r. 
</p>
<p><code>
d = Direction_2(&lt;<strong>int</strong>&gt; x, &lt;<strong>int</strong>&gt; y)
</code>
Introduces a direction d passing through the origin and the point with Cartesian coordinates (x, y).
</p>
<a name="operators"></a><h3 style="color:#111;">Operators</h3>
<p><code><strong>bool</strong>  d==e</code>
Returns true if d and e Direction_2 objects has the same coordinates.
Returns false otherwise.
</p>
<p><code><strong>bool</strong>  d!=e</code>
Returns true if p and e Direction_2 objects has not the same coordinates.
Returns false otherwise.
</p>
<p><code><strong>bool</strong>  d&le;e</code>
Returns true if d coordinates are lesser or equal than e.
Returns false otherwise.
</p>
<p><code><strong>bool</strong>  d&ge;e</code>
Returns true if d coordinates are greater or equal than e.
Returns false otherwise.
</p>
<p><code><strong>bool</strong>  d&lt;e</code>
Returns true if d coordinates are lesser than e.
Returns false otherwise.
</p>
<p><code><strong>bool</strong>  d&gt;e</code>
Returns true if d coordinates are greater than e.
Returns false otherwise.
</p>
<p><code><strong><a href="#Ldirection2d">Direction_2</a></strong>  -d</code>
Returns the opposite direction.
</p>
<a name="operations"></a><h3 style="color:#111;">Operations</h3>
<p><code><strong>float</strong>  d.delta(int i)</code>
Returns values, such that d== Direction_2(delta(0),delta(1)). (0&le;i&le;1)
</p>
<p><code><strong>float</strong>  d.dx()</code>
Returns delta(0).
</p>
<p><code><strong>float</strong>  d.dy()</code>
Returns delta(1).
</p>
<p><code><strong>bool</strong>  d.counterclockwise_in_between ( d1, d2) </code>
Returns true, iff d is not equal to d1, and while rotating counterclockwise starting at d1, d is reached strictly before d2 is reached. Note that true is returned if d1 == d2, unless also d == d1. 
</p>
<p><code><strong><a href="#Lvector2d">Vector_2</a></strong>  d.to_vector()</code>
Returns a vector that has the same direction as d.
</p>
</p>
<a href="#Ldirection2d">Direction_2</a>&nbsp;&nbsp;&nbsp;<a href="#Library">Library</a>&nbsp;&nbsp;&nbsp;<a href="#">Top</a><br /></div></li>
<li><p><a id="Ltriangle2d">Triangle_2</a>&nbsp;<a href="javascript:animatedcollapse.toggle('ltriangle2d')"><i>Show/Hide</i></a></p>
<div id="ltriangle2d" style="display: none;">
<p>
<h3 style="color:#111;">Definition</h3>

<p>
An object t of the class Triangle_2 is a triangle in the two-dimensional Euclidean plane. Triangle t is oriented, i.e., its boundary has clockwise or counterclockwise orientation. We call the side to the left of the boundary the positive side and the side to the right of the boundary the negative side.
</p>
<p>
The boundary of a triangle splits the plane in two open regions, a bounded one and an unbounded one. 
</p>
<a name="constructor"></a><h3 style="color:#111;">Constructor</h3>
<p><code>t = Triangle_2(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p,&lt;<a href="#Lpoint2d">Point_2</a>&gt; q, color=(1,1,1), visible=True)</code>
Introduces a triangle t with vertices p, q and r.
</p>
<a name="operators"></a><h3 style="color:#111;">Operators</h3>
<p><code><strong>bool</strong>  t1==t2</code>
Test for equality: two triangles are equal, iff there exists a cyclic permutation of the vertices of t2, such that they are equal to the vertices of t. 
</p>
<p><code><strong>bool</strong>  t1!=t2</code>
Test for inequality. 
</p>
<p><code><strong><a href="#Lpoint2d">Point_2</a></strong>  t[int i]</code>
Returns vertex(i). 
</p>
<a name="operations"></a><h3 style="color:#111;">Operations</h3>
<p><code><strong><a href="#Lpoint2d">Point_2</a></strong>  t.vertex(int i)</code>
Returns the i'th vertex modulo 3 of t.
</p>
<p><code><strong><a href="#Ltriangle2d">Triangle_2</a></strong>  t.opposite()</code>
Returns a triangle where the boundary is oriented the other way round (this flips the positive and the negative side, but not the bounded and unbounded side).
</p>
<p><code><strong>float</strong>  t.area()</code>
Returns the signed area of t (with the help of <a href="http://en.wikipedia.org/wiki/Heron%27s_formula">Heron Formula</a>). 
</p>
<p><code><strong>void</strong>  t.fill(x,y,z)</code>
If color is called as p.fill() prints the color of the Triangle_2<br />
If it is called with with tuple (color.green) or (256,0,0) then it changes
the filling of the Triangle_2.<br />
</p>
<p><code><strong>void</strong>  t.poi_color(x,y,z)</code>
If color is called as p.fill() prints the color of the points Triangle_2<br />
If it is called with with tuple (color.green) or (256,0,0) then it changes
the color of the points of the Triangle_2.<br />
</p>
<p><code><strong>void</strong>  t.seg_color(x,y,z)</code>
If color is called as p.fill() prints the color of the segments Triangle_2<br />
If it is called with with tuple (color.green) or (256,0,0) then it changes
the color of the segments of the Triangle_2.<br />
</p>
<a name="predicates"></a><h3 style="color:#111;">Predicates</h3>
<p><code><strong>bool</strong> t.is_degenerate()</code>
Triangle t is degenerate, if the vertices are collinear. 
</p>
<p><code><strong>Orientation</strong> t.orientation()</code>
Returns the orientation of t.
</p>
<p><code><strong>Oriented side</strong> t.oriented_side(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
Returns ON_ORIENTED_BOUNDARY, or POSITIVE_SIDE, or the constant ON_NEGATIVE_SIDE, determined by the position of point p.
Precondition: t is not degenerate.
</p>
<p><code><strong>Bounted side</strong> t.bounded_side(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
Returns the constant ON_BOUNDARY, ON_BOUNDED_SIDE, or else ON_UNBOUNDED_SIDE, depending on where point p is.
Precondition: t is not degenerate.
</p>
<p><code><strong>bool</strong> t.has_on_positive_side(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
<code><strong>bool</strong> t.has_on_negative_side(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
<code><strong>bool</strong> t.has_on_boundary(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
<code><strong>bool</strong> t.has_on_bounded_side(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
<code><strong>bool</strong> t.has_on_unbounded_side(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
</p>
</p>
<a href="#Ltriangle2d">Triangle_2</a>&nbsp;&nbsp;&nbsp;<a href="#Library">Library</a>&nbsp;&nbsp;&nbsp;<a href="#">Top</a><br /></div></li>
<li><p><a id="Lline2d">Line_2</a>&nbsp;<a href="javascript:animatedcollapse.toggle('lline2d')"><i>Show/Hide</i></a></p>
<div id="lline2d" style="display: none;">
<p>
<h3 style="color:#111;">Definition</h3>
<p>
An object l of the data type Line_2 is a directed straight line in the two-dimensional Euclidean plane. It is defined by the set of points with Cartesian coordinates (x,y) that satisfy the equation l : ax + by + c = 0
</p>
<p>
The line splits two-dimensional Euclidean plane in a positive and a negative side. A point p with Cartesian coordinates (px, py) is on the positive side of l, iff a px + b py + c > 0, it is on the negative side of l, iff a px + b py + c < 0. The positive side is to the left of l. 
</p>
<a name="constructor"></a><h3 style="color:#111;">Constructor</h3>
<p><code>l = Line_2(int a, int b, int c color=(1,1,1), visible=True)</code>
Introduces a line l with the line equation in Cartesian coordinates ax +by +c = 0.
</p>
<p><code>l = Line_2(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p,&lt;<a href="#Lpoint2d">Point_2</a>&gt; q, color=(1,1,1), visible=True)</code>
Introduces a line l passing through the points p and q. Line l is directed from p to q
</p>
<p><code>l = Line_2(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p,&lt;<a href="#Ldirection2d">Direction_2</a>&gt; d,color=(1,1,1), visible=True)</code>
Introduces a line l passing through point p with direction d. 
</p>
<p><code>l = Line_2(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p,&lt;<a href="#Lvector2d">Vector_2</a>&gt; v, color=(1,1,1), visible=True)</code>
Introduces a line l passing through point p and oriented by v. 
</p>
<p><code>l = Line_2(&lt;<a href="#Lsegment2d">Segment_2</a>&gt; s, color=(1,1,1), visible=True)</code>
Introduces a line l supporting the segment s, oriented from source to target.
</p>
<p><code>l = Line_2(&lt;<a href="#Lray2d">Ray_2</a>&gt; r, color=(1,1,1), visible=True)</code>
Introduces a line l supporting the ray r, with same orientation. 
</p>
<a name="operators"></a><h3 style="color:#111;">Operators</h3>
<p><code><strong>bool</strong>  l==h</code>
Test for equality: Two lines are equal, iff the intersection of the lines are a line.
</p>
<p><code><strong>bool</strong>  l!=h</code>
Test for inequality. 
</p>
<a name="operations"></a><h3 style="color:#111;">Operations</h3>
<p><code><strong>int</strong> l.a()</code>
Returns the first coefficient of l. 
</p>
<p><code><strong>int</strong> l.b()</code>
Returns the second coefficient of l. 
</p>
<p><code><strong>int</strong> l.c()</code>
Returns the third coefficient of l. 
</p>
<p><code><strong>int</strong> l.x_at_y()</code>
Returns the x-coordinate of the point at l with given y-coordinate.
Precondition: l is not horizontal.
</p>
<p><code><strong>int</strong> l.y_at_x()</code>
Returns the y-coordinate of the point at l with given x-coordinate.
Precondition: l is not vertical.
</p>
<p><code><strong><a href="#Lpoint2d">Point_2</a></strong> l.point(int i)</code>
Returns an arbitrary point on l. It holds point(i) == point(j), iff i==j. Furthermore, l is directed from point(i) to point(j), for all i &lt; j.
</p>
<p><code><strong><a href="#Lpoint2d">Point_2</a></strong> l.projection(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
Returns the orthogonal projection of p onto l.
</p>
<p><code><strong><a href="#Lvector2d">Vector_2</a></strong>  l.to_vector()</code>
Returns a vector that has the direction of l.
</p>
<p><code><strong><a href="#Ldirection2d">Direction_2</a></strong>  l.direction()</code>
Returns the direction of l.
</p>
<p><code><strong><a href="#Lline2d">Line_2</a></strong>  l.opposite()</code>
Returns the line with opposite direction. 
</p>
<p><code><strong><a href="#Lline2d">Line_2</a></strong>  l.perpendicular(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
Returns the line perpendicular to l and passing through p, where the direction is the direction of l rotated counterclockwise by 90 degrees. 
</p>
<a name="predicates"></a><h3 style="color:#111;">Predicates</h3>
<p><code><strong>bool</strong> l.is_degenerate()</code>
Line l is degenerate, if the coefficients a and b of the line equation are zero. 
</p>
<p><code><strong>bool</strong> l.is_horizontal()</code>
</p>
<p><code><strong>bool</strong> l.is_vertical()</code>
</p>
<p><code><strong>Oriented side</strong> l.oriented_side(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
Returns ON_ORIENTED_BOUNDARY, ON_NEGATIVE_SIDE, or the constant ON_POSITIVE_SIDE, depending on the position of p relative to the oriented line l.
</p>
For convenience we provide the following Boolean functions: 
<p><code><strong>bool</strong> l.has_on(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
</p>
<p><code><strong>bool</strong> l.has_on_positive_side(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
</p>
<p><code><strong>bool</strong> l.has_on_negative_side(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
</p>
</p>
<a href="#Lline2d">Line_2</a>&nbsp;&nbsp;&nbsp;<a href="#Library">Library</a>&nbsp;&nbsp;&nbsp;<a href="#">Top</a><br /></div></li>
<li><p><a id="Lray2d">Ray_2</a>&nbsp;<a href="javascript:animatedcollapse.toggle('lray2d')"><i>Show/Hide</i></a></p>
<div id="lray2d" style="display: none;">
<p>
<h3 style="color:#111;">Definition</h3>
<p>
An object r of the data type Ray_2 is a directed straight ray in the two-dimensional Euclidean plane. It starts in a point called the source of r and goes to infinity. 
</p>
<a name="constructor"></a><h3 style="color:#111;">Constructor</h3>
<p><code>r = Ray_2(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p,&lt;<a href="#Lpoint2d">Point_2</a>&gt; q, color=(1,1,1), visible=True)</code>
Introduces a ray r with source p and passing through point q. 
</p>
<p><code>r= Ray_2(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p,&lt;<a href="#Ldirection2d">Direction_2</a>&gt; d,color=(1,1,1), visible=True)</code>
Introduces a ray r starting at source p with direction d. 
</p>
<p><code>r = Ray_2(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p,&lt;<a href="#Lvector2d">Vector_2</a>&gt; v, color=(1,1,1), visible=True)</code>
Introduces a ray r starting at source p with the direction of v. 
</p>
<p><code>r = Ray_2(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p,&lt;<a href="#Lline2d">Line_2</a>&gt; l, color=(1,1,1), visible=True)</code>
Introduces a ray r starting at source p with the same direction as l. 
</p>
<a name="operators"></a><h3 style="color:#111;">Operators</h3>
<p><code><strong>bool</strong>  r==h</code>
Test for equality: two rays are equal, iff they have the same source and the same direction. 
</p>
<p><code><strong>bool</strong>  r!=h</code>
Test for inequality. 
</p>
<a name="operations"></a><h3 style="color:#111;">Operations</h3>
<p><code><strong><a href="#Lvector2d">Vector_2</a></strong>  r.to_vector()</code>
Returns a vector that has the direction of r.
</p>
<p><code><strong><a href="#Ldirection2d">Direction_2</a></strong>  r.direction()</code>
Returns the direction of r.
</p>
<p><code><strong><a href="#Lray2d">Ray_2</a></strong>  r.opposite()</code>
Returns the ray with the same source and the opposite direction. 
</p>
<p><code><strong><a href="#Lline2d">Line_2</a></strong>  r.supporting_line()</code>
Returns the line supporting r which has the same direction. 
</p>
<a name="predicates"></a><h3 style="color:#111;">Predicates</h3>
<p><code><strong>bool</strong> r.is_degenerate()</code>
Ray r is degenerate, if the source and the second defining point fall together (that is if the direction is degenerate).
</p>
<p><code><strong>bool</strong> r.is_horizontal()</code>
</p>
<p><code><strong>bool</strong> r.is_vertical()</code>
</p>
<p><code><strong>bool</strong> r.has_on(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
A point is on r, iff it is equal to the source of r, or if it is in the interior of r. 
</p>
</p>
<a href="#Lray2d">Ray_2</a>&nbsp;&nbsp;&nbsp;<a href="#Library">Library</a>&nbsp;&nbsp;&nbsp;<a href="#">Top</a><br /></div></li>
<li><p><a id="Lcircle2d">Circle_2</a>&nbsp;<a href="javascript:animatedcollapse.toggle('lcircle2d')"><i>Show/Hide</i></a></p>
<div id="lcircle2d" style="display: none;">
<p>
<h3 style="color:#111;">Definition</h3>
<p>
An object of type Circle_2 is a circle in the two-dimensional Euclidean plane. The circle is oriented, i.e. its boundary has clockwise or counterclockwise orientation . The boundary splits 2 into a positive and a negative side, where the positive side is to the left of the boundary. The boundary also splits 2 into a bounded and an unbounded side. Note that the circle can be degenerated, i.e. the squared radius may be zero. 
</p>
<a name="constructor"></a><h3 style="color:#111;">Constructor</h3>
<p><code>c = Circle_2(&lt;<a href="#Lpoint2d">Point_2</a>&gt; center,(int|float) squared_radius, Orientation ori = COUNTERCLOCKWISE, color=(1,1,1), visible=True)</code>
Introduces a variable c of type Circle_2. It is initialized to the circle with center center, squared radius squared_radius and orientation ori.
Precondition: ori &ne; COLLINEAR, and further, squared_radius greater or equal 0.
</p>
<p><code>c = Circle_2(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p,&lt;<a href="#Lpoint2d">Point_2</a>&gt; q,Orientation ori = COUNTERCLOCKWISE, color=(1,1,1), visible=True)</code>
Introduces a variable c of type Circle_2. It is initialized to the circle with diameter pq and orientation ori.
Precondition: ori &ne; COLLINEAR.
</p>
<p><code>c = Circle_2(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p, &lt;<a href="#Lpoint2d">Point_2</a>&gt; q ,&lt;<a href="#Lpoint2d">Point_2</a>&gt; r, color=(1,1,1), visible=True)</code>
Introduces a variable c of type Circle_2. It is initialized to the unique circle which passes through the points p, q and r. The orientation of the circle is the orientation of the point triple p, q, r.
Precondition: 	p, q, and r are not collinear.
</p>
<p><code>c = Circle_2(&lt;<a href="#Lpoint2d">Point_2</a>&gt; center, Orientation ori, color=(1,1,1), visible=True)</code>
Introduces a variable c of type Circle_2. It is initialized to the circle with center center, squared radius zero and orientation ori.
Precondition: 	ori &ne; COLLINEAR.
Postcondition: 	c.is_degenerate() = true.
</p>
<a name="operators"></a><h3 style="color:#111;">Operators</h3>
<p><code><strong>bool</strong>  c==circle2</code>
Returns true, iff c and circle2 are equal, i.e. if they have the same center, same squared radius and same orientation .
</p>
<p><code><strong>bool</strong>  c!=circle2</code>
Returns true, iff c and circle2 are not equal. 
</p>
<a name="operations"></a><h3 style="color:#111;">Operations</h3>
<p><code><strong><a href="#Lpoint2d">Point_2</a></strong> c.center()</code>
Returns the center of c.
</p>
<p><code><strong>int | float</strong> c.squared_radius()</code>
Returns the squared radius of c.
</p>
<p><code><strong>Orientation</strong> c.orientation()</code>
Returns the orientation of c.
</p>
<p><code><strong><a href="#Lcircle2d">Circle_2</a></strong>  c.opposite()</code>
Returns the circle with the same center and squared radius as c but with opposite orientation.
</p>
<a name="predicates"></a><h3 style="color:#111;">Predicates</h3>
<p><code><strong>bool</strong> c.is_degenerate()</code>
Returns true, iff c is degenerate, i.e. if c has squared radius zero. 
</p>
<p><code><strong>Oriented side</strong> c.oriented_side(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
Returns either the constant ON_ORIENTED_BOUNDARY, ON_POSITIVE_SIDE, or ON_NEGATIVE_SIDE, iff p lies on the boundary, properly on the positive side, or properly on the negative side of c, resp.
</p>
<p><code><strong>Bounted side</strong> c.bounded_side(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
Returns ON_BOUNDED_SIDE, ON_BOUNDARY, or ON_UNBOUNDED_SIDE iff p lies properly inside, on the boundary, or properly outside of c, resp. 
</p>
<p><code><strong>bool</strong> c.has_on_positive_side(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
<code><strong>bool</strong> c.has_on_negative_side(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
<code><strong>bool</strong> c.has_on_boundary(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
<code><strong>bool</strong> c.has_on_bounded_side(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
<code><strong>bool</strong> c.has_on_unbounded_side(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
</p>
</p>
<a href="#Lcircle2d">Circle_2</a>&nbsp;&nbsp;&nbsp;<a href="#Library">Library</a>&nbsp;&nbsp;&nbsp;<a href="#">Top</a><br /></div></li>
<li><p><a id="Lpolygon2d">Polygon_2</a>&nbsp;<a href="javascript:animatedcollapse.toggle('lpolygon2d')"><i>Show/Hide</i></a></p>
<div id="lpolygon2d" style="display: none;">
<p>
<h3 style="color:#111;">Definition</h3>
<p>
An object pgn of the data type Polygon_2 is a plane figure that is bounded by a closed path or circuit, composed of a finite sequence of straight line segments.
</p>
<a name="constructor"></a><h3 style="color:#111;">Constructor</h3>
<p><code>pgn = Polygon_2(&lt;<a href="#Lpoint2d">Point_2</a> list&gt; points,&lt;<a href="#Lsegment2d">Segment_2</a> list&gt; segments=None, color=(1,1,1), visible=True)</code>
Introduces a polygon pgn with vertices from the list points. The segments list can be filled with the output of getPolygon function.
</p>
<a name="operators"></a><h3 style="color:#111;">Operators</h3>
<p><code><strong>bool</strong>  p1==p2</code>
Test for equality: two polygons are equal iff there exists a cyclic permutation of the vertices of p2 such that they are equal to the vertices of p1. Note that the template argument Container of p1 and p2 may be different. 
</p>
<p><code><strong>bool</strong>  p1!=p2</code>
Test for inequality. 
</p>
<p><code><strong><a href="#Lpoint2d">Point_2</a></strong>  p[ int i]</code>
Returns the i-th vertex. 
</p>
<a name="operations"></a><h3 style="color:#111;">Operations</h3>
<p><code><strong>float</strong>  pgn.area()</code>
Returns the signed area of the polygon pgn. This means that the area is positive for counter clockwise polygons and negative for clockwise polygons. 
</p>
<p><code><strong>int</strong> pgn.size()</code>
Returns the number of vertices of the polygon pgn.
</p>
<p><code><strong><a href="#Lpoint2d">Point_2</a></strong>  p[ int i]</code>
Returns the i-th vertex. 
</p>
<p><code><strong><a href="#Lpoint2d">Point_2</a></strong>  p.vertex(int i)</code>
Returns the i-th vertex. 
</p>
<p><code><strong><a href="#Lsegment2d">Segment_2</a></strong> p.edge(int i)</code>
Returns the i-th edge. 
</p>
<p><code><strong><a href="#Lpolygon2d">Polygon_2</a></strong> p.reverse_orientation()</code>
Reverses the orientation of the polygon. The vertex pointed to by p[0] remains the same. 
</p>
<p><code><strong>void</strong> p.insert(int i,<a href="#Lpoint2d">Point_2</a> q)</code>
Inserts the vertex q before i. 
</p>
<p><code><strong>void</strong> p.insert(int i,<a href="#Lpoint2d">Point_2</a> list q)</code>
Inserts the list of vertex q before i.
</p>
<p><code><strong>void</strong> p.erase(int i)</code>
Erases the vertex pointed to by i.
</p>
<p><code><strong>void</strong> p.erase(int first, int last</code>
Erases the vertices in the range [first, last). 
</p>
<p><code><strong>void</strong> p.push_back(<a href="#Lpoint2d">Point_2</a> q)</code>
Has the same semantics as p.insert(p.size(), q). 
</p>
<p><code><strong>void</strong> p.clear()</code>
Erases all vertices.
</p>
<p><code><strong>void</strong>  p.poi_color(x,y,z)</code>
If color is called as p.fill() prints the color of the points Triangle_2<br />
If it is called with with tuple (color.green) or (256,0,0) then it changes
the color of the points of the Triangle_2.<br />
</p>
<p><code><strong>void</strong>  p.seg_color(x,y,z)</code>
If color is called as p.fill() prints the color of the segments Triangle_2<br />
If it is called with with tuple (color.green) or (256,0,0) then it changes
the color of the segments of the Triangle_2.<br />
</p>
<a name="predicates"></a><h3 style="color:#111;">Predicates</h3>
<p><code><strong>bool</strong> pgn.is_simple()</code>
Returns whether p is a simple polygon. 
</p>
<p><code><strong>bool</strong> pgn.is_convex()</code>
Returns whether p is convex. 
</p>
<p><code><strong>bool</strong> pgn.is_empty()</code>
Returns pgn.size() == 0. 
</p>
<p><code><strong>Orientation</strong> pgn.orientation()</code>
Returns the orientation of pgn.
</p>
<p><code><strong>Oriented side</strong> p.oriented_side(&lt;<a href="#Lpoint2d">Point_2</a>&gt; q)</code>
Returns POSITIVE_SIDE, or NEGATIVE_SIDE, or ON_ORIENTED_BOUNDARY, depending on where point q is.
Precondition: p.is_simple().
</p>
<p><code><strong>Bounted side</strong> p.bounded_side(&lt;<a href="#Lpoint2d">Point_2</a>&gt; q)</code>
Returns the symbolic constant ON_BOUNDED_SIDE, ON_BOUNDARY or ON_UNBOUNDED_SIDE, depending on where point q is.
Precondition: p.is_simple().
</p>
<p><code><strong><a href="#Lpoint2d">Point_2</a></strong> p.left_vertex()</code>
Returns the leftmost vertex of the polygon p with the smallest y-coordinate. 
</p>
<p><code><strong><a href="#Lpoint2d">Point_2</a></strong> p.right_vertex()</code>
Returns the rightmost vertex of the polygon p with the largest y-coordinate.
</p>
<p><code><strong><a href="#Lpoint2d">Point_2</a></strong> p.top_vertex()</code>
Returns topmost vertex of the polygon p with the largest x-coordinate. 
</p>
<p><code><strong><a href="#Lpoint2d">Point_2</a></strong>  p.bottom_vertex()</code>
Returns the bottommost vertex of the polygon p with the smallest x-coordinate.
</p>
<p><code><strong>bool</strong> pgn.is_counterclockwise_oriented()</code>
<code><strong>bool</strong> pgn.is_clockwise_oriented ()</code>
<code><strong>bool</strong> pgn.has_on_positive_side(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
<code><strong>bool</strong> pgn.has_on_negative_side(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
<code><strong>bool</strong> pgn.has_on_boundary(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
<code><strong>bool</strong> pgn.has_on_bounded_side(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>
<code><strong>bool</strong> pgn.has_on_unbounded_side(&lt;<a href="#Lpoint2d">Point_2</a>&gt; p)</code>

</p>
</p>
<a href="#Lpolygon2d">Polygon_2</a><br /></div></li>
</ul>
<a href="#Library">Library</a>&nbsp;&nbsp;&nbsp;<a href="#">Top</a><br />
</div>
<a id="Releases">Releases</a> <p><a href="javascript:animatedcollapse.toggle('release')"><i>Show/Hide</i></a></p>
<div id="release" style="display: none;">
<p>
The project is held in an svn repository in code.google.com.<br />
In order to checkout the source see the project <a href="http://code.google.com/p/eucleidis/" target="_blank">page</a><br/>
<br />
With the next piece of code you can checkout a read-only working copy.<br />
<br />
<code>svn checkout http://eucleidis.googlecode.com/svn/trunk/ eucleidis-read-only</code>
<br />
The first stable release can be download as a zip file.<br />
You can find it <a href="http://code.google.com/p/eucleidis/downloads/list" target="_blank">here</a><br/>
<br />
If you want to contribute to the source code you can send<br />
an email and I will grand you access to commit in the repository.<br />
</p>
<a href="#Releases">Releases</a>&nbsp;&nbsp;&nbsp;<a href="#">Top</a><br />
</div>
<a id="Examples">Examples</a> <p><a href="javascript:animatedcollapse.toggle('example')"><i>Show/Hide</i></a></p>
<div id="example" style="display: none;">
<h3>Classes</h3>
<ul>
<li><p><a id="Epoint2d">Point_2</a>&nbsp;<a href="javascript:animatedcollapse.toggle('epoint2d')"><i>Show/Hide</i></a></p>
<div id="epoint2d" style="display: none;">
<p>
<img src="./examples/point2d.png" alt="point2d" height="500" width="500" />
<p><code>from eucleidis import *
<br />a = Point_2()
<br />b = Point_2(2,1)
<br />b.color(1,0,0)
<br />c = Point_2(1,2)
<br />c.color(color.red)
<br />c.color(color.green)
<br />d = Point_2(-1,2)
<br />c.color(visual.color.red)
<br />c.color(color.green)
<br />d.color(color.cyan)
<br />d.label("d")
<br /></code></p>
</p>
<a href="#Epoint2d">Point_2</a>&nbsp;&nbsp;&nbsp;<a href="#Examples">Library</a>&nbsp;&nbsp;&nbsp;<a href="#">Top</a><br /></div></li>
<li><p><a id="Esegment2d">Segment_2</a>&nbsp;<a href="javascript:animatedcollapse.toggle('esegment2d')"><i>Show/Hide</i></a></p>
<div id="esegment2d" style="display: none;">
<p>
<img src="./examples/segment2d.png" alt="segment2d" height="500" width="500" />
<p><code>from eucleidis import *
<br />a = Point_2()
<br />b = Point_2(5,1)
<br />s1 = Segment_2(a,b)
<br />s1.color(1,0,0)
<br />c = Point_2(-1,2)
<br />d = Point_2(-1,5)
<br />s2 = Segment_2(c,d)
<br />s2.color(color.blue)
<br />s2.label("s2")
<br /></code></p>
</p>
<a href="#Esegment2d">Segment_2</a>&nbsp;&nbsp;&nbsp;<a href="#Examples">Library</a>&nbsp;&nbsp;&nbsp;<a href="#">Top</a><br /></div></li>
<li><p><a id="Evector2d">Vector_2</a>&nbsp;<a href="javascript:animatedcollapse.toggle('evector2d')"><i>Show/Hide</i></a></p>
<div id="evector2d" style="display: none;">
<p>
We are sorry but this class<br />(the vector or the direction) has no image.<br />This is because these classes<br />are only for intrenal purposes of the EucleiDIs library.<br />Try some other class in order to view pictures and code for this class.<br />		
</p>
<a href="#Evector2d">Vector_2</a>&nbsp;&nbsp;&nbsp;<a href="#Examples">Library</a>&nbsp;&nbsp;&nbsp;<a href="#">Top</a><br /></div></li>
<li><p><a id="Edirection2d">Direction_2</a>&nbsp;<a href="javascript:animatedcollapse.toggle('edirection2d')"><i>Show/Hide</i></a></p>
<div id="edirection2d" style="display: none;">
<p>
We are sorry but this class<br />(the vector or the direction) has no image.<br />This is because these classes<br />are only for intrenal purposes of the EucleiDIs library.<br />Try some other class in order to view pictures and code for this class.<br />
</p>
<a href="#Edirection2d">Direction_2</a>&nbsp;&nbsp;&nbsp;<a href="#Examples">Library</a>&nbsp;&nbsp;&nbsp;<a href="#">Top</a><br /></div></li>
<li><p><a id="Etriangle2d">Triangle_2</a>&nbsp;<a href="javascript:animatedcollapse.toggle('etriangle2d')"><i>Show/Hide</i></a></p>
<div id="etriangle2d" style="display: none;">
<p>
<img src="./examples/triangle2d.png" alt="triangle2d" height="500" width="500" />
<p><code>from eucleidis import *
<br />p1 = Point_2()
<br />p2 = Point_2(1,-2)
<br />p3 = Point_2(3,5)
<br />t1 = Triangle_2(p1,p2,p3)
<br />t1.area()
<br />398.02512483510384
<br />t1.orientation()
<br />1
<br />rorien[t1.orientation()]
<br />'COUNTERCLOCKWISE'
<br />t1.seg_color(color.cyan)
<br />t1.poi_color(1,0.7,0.2)
<br />t1.fill(color.red)
<br /></code></p>
</p>
<a href="#Etriangle2d">Triangle_2</a>&nbsp;&nbsp;&nbsp;<a href="#Examples">Library</a>&nbsp;&nbsp;&nbsp;<a href="#">Top</a><br /></div></li>
<li><p><a id="Eline2d">Line_2</a>&nbsp;<a href="javascript:animatedcollapse.toggle('eline2d')"><i>Show/Hide</i></a></p>
<div id="eline2d" style="display: none;">
<p>
<img src="./examples/line2d.png" alt="line2d" height="500" width="500" />
<p><code>from eucleidis import *
<br />p1 = Point_2()
<br />p2 = Point_2(3,4)
<br />l1 = Line_2(p1,p2)
<br />l1.color(0,1,0)
<br />p3 = Point_2(-1,5)
<br />l2 = l1.perpendicular(p3)
<br />l2.visual()
<br />True
<br />l2.color(1,1,0)
<br />l3 = Line_2(p3,p1)
<br /></code></p>
</p>
<a href="#Eline2d">Line_2</a>&nbsp;&nbsp;&nbsp;<a href="#Examples">Library</a>&nbsp;&nbsp;&nbsp;<a href="#">Top</a><br /></div></li>
<li><p><a id="Eray2d">Ray_2</a>&nbsp;<a href="javascript:animatedcollapse.toggle('eray2d')"><i>Show/Hide</i></a></p>
<div id="eray2d" style="display: none;">
<p>
<img src="./examples/ray2d.png" alt="ray2d" height="500" width="500" />
<p><code>from eucleidis import *
<br />p1 = Point_2()
<br />p2 = Point_2(-1,-2)
<br />r1 = Ray_2(p1,p2)
<br />r1.color(0,1,1)
<br />r1.source().color(1,0,1)
<br />p3 = Point_2(6,2)
<br />r2 = Ray_2(p2,p3)
<br />r2.color(1,0,0)
<br />r3 = r2.opposite()
<br />r3.visual()
<br />True
<br />r3.color(color.orange)
<br /></code></p>
</p>
<a href="#Eray2d">Ray_2</a>&nbsp;&nbsp;&nbsp;<a href="#Examples">Library</a>&nbsp;&nbsp;&nbsp;<a href="#">Top</a><br /></div></li>
<li><p><a id="Ecircle2d">Circle_2</a>&nbsp;<a href="javascript:animatedcollapse.toggle('ecircle2d')"><i>Show/Hide</i></a></p>
<div id="ecircle2d" style="display: none;">
<p>
<img src="./examples/circle2d.png" alt="circle2d" height="500" width="500" />
<p><code>from eucleidis import *
<br />p1 = Point_2()
<br />p2 = Point_2(4,5)
<br />c1 = Circle_2(p1,p2)
<br />c1.center().visual()
<br />True
<br />c1.center_color(1,0,0)
<br />c1.ring_color(0.5,0.7,0.2)
<br />c2 = Circle_2(c1.center(),p1)
<br />c2.ring_color(0,0,1)
<br /></code></p>
</p>
<a href="#Ecircle2d">Circle_2</a>&nbsp;&nbsp;&nbsp;<a href="#Examples">Library</a>&nbsp;&nbsp;&nbsp;<a href="#">Top</a><br /></div></li>
<li><p><a id="Epolygon2d">Polygon_2</a>&nbsp;<a href="javascript:animatedcollapse.toggle('epolygon2d')"><i>Show/Hide</i></a></p>
<div id="epolygon2d" style="display: none;">
<p>
<img src="./examples/polygon2d.png" alt="polygon2d" height="500" width="500" />
<p><code>from eucleidis import *
<br />p1 =Point_2()
<br />p2 = Point_2(4,5)
<br />p3 = Point_2(0,5)
<br />p4 = Point_2(7,0)
<br />p5 = Point_2(2,-2)
<br />poly = Polygon_2([p1,p3,p2,p4,p5])
<br />poly.poi_color(color.yellow)
<br />poly.seg_color(color.cyan)
<br /></code></p>
</p><a href="#Epolygon2d">Polygon_2</a><br /></div></li>
</ul>
<a href="#Examples">Examples</a>&nbsp;&nbsp;&nbsp;<a href="#">Top</a><br />
</div>
<a id="About">About</a> <p><a href="javascript:animatedcollapse.toggle('about')"><i>Show/Hide</i></a></p>
<div id="about" style="display: none;">
<p>
General information you can find in the <a href="./">home</a>
This library started at February of 2011 as my Bachelor thesis
in the <a href="http://www.uoa.gr">University of Athens</a> at the
<a href="http://www.di.uoa.gr">Deparment of Informatics and Telecomunications</a>.
My supervisors are <a href="http://www.di.uoa.gr/~emiris">Ioannis EMIRIS</a> and <a href="https://sites.google.com/site/christodoulosfragoudakis/">Christodoulos FRAGOUDAKIS</a>.
It is designed in order to be used from the students of the computational geometry
course at the same department. Because the previous methods was difficult to be
installed and maintained, the desicion of making a new library from scratch, was made.
</p>
<p>
We used Python because it is really easy to transform pseudo code to a well designed
program ready to be executed in every machine.
</p>
<p>
I have tried to imitate CGAL because it is the best existing library we know.
I tried to have the same names of the functions. Hence it will be easy for 
someone that had used CGAL to do the same things with this library.
</p>
<p>
EucleiDIs uses the <a href="http://www.vpython.org">VPython</a> (it can be easily installed in *NIX based systems
and with little effort to Windows) library to take the simple objects it needs (points as spheres, ...).
</p>
<p>
Trying to have backward compatibility with the VPython the only mouse button we use is the right one.
In the newer versions of VPython the other buttons are used for altering the scene (zoom in -out, spin)
</p>
<a href="#About">About</a>&nbsp;&nbsp;&nbsp;<a href="#">Top</a><br />
</div>
<a href="#">Top</a><br />
</section>
</div>
    <footer>
      <p>Project maintained by <a href="https://github.com/sfagmenos">sfagmenos</a></p>
      <p>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></p>
    </footer>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
